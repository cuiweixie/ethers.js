_section: 事件 @<events>

_subsection: 日志和过滤器（Logs and Filtering）

在区块链的应用程序中经常用到日志和过滤器，因为它可以对索引数据进行高效查询，并且针对不在链上的数据可以提供低成本的数据存储。

这些可以结合[提供者事件API](Provider--event-methods)以及[合约事件API](Contract--events)一起使用。

合约事件API也提供了[高级方法](Contract--filters)去计算和查询数据，这种方式要优先于低级的过滤器。

_heading: 过滤器 @<events--filters>

当合约创建一条日志时，它包含了4条可索引的数据。这些索引数据经过哈希加密，且包含在一个[[link-wiki-bloomfilter]]中， [[link-wiki-bloomfilter]]是一种允许高效过滤的数据结构。

因此，过滤器相应地可能多达4个主题集，其中每个主题集指向一个条件，该条件必须匹配该位置的索引日志主题(即每个条件都是``AND``语句连接在一起的)。

如果一个主题集为 ``null``, 则该位置的日志主题 **不过滤**  且与  **任何值**  都匹配。

如果一个主题集是单个主题，则该位置的日志主题 **必须** 匹配 **这个主题**。

如果主题集是一个数组，则该位置的日志主题必须匹配其中  **任何一个**  主题(即每个条件都是``OR``语句连接在一起的)。

虽然一开始听起来有点复杂绕口，但通过以下例子可以很好地帮助你理解。

_table: 匹配日志的例子 @style<full>

$TopicABaCD: **[** (topic[0] = A) **OR** (topic[0] = B) **]** **AND**
             **[** (topic[1] = C) **OR** (topic[1] = D) **]**

|  **主题集**           |  **匹配日志**                    <<|
|   [ A ]                   | topic[0] = A                          <<|
|   [ A, null ]             |   ^                                     |
|   [ null, B ]             | topic[1] = B                          <<|
|   [ null, [ B ] ]         |   ^                                     |
|   [ null, [ B ], null ]   |   ^                                     |
|   [ A, B ]                | (topic[0] = A) **AND** (topic[1] = B) <<|
|   [ A, [ B ] ]            |   ^                                     |
|   [ A, [ B ], null ]      |   ^                                     |
|   [ [ A, B ] ]            | (topic[0] = A) **OR** (topic[0] = B)  <<|
|   [ [ A, B ], null ]      |   ^                                     |
|   [ [ A, B ], [ C, D ] ]  | $TopicABaCD                       <<|


_code: ERC-20 转账过滤的例子 @lang<javascript>

//_hide: const tokenAddress = ethers.constants.AddressZero;
//_hide: const myAddress = ethers.constants.AddressZero;
//_hide: const myOtherAddress = ethers.constants.AddressZero;
//_hide: const id = ethers.utils.id;
//_hide: const hexZeroPad = ethers.utils.hexZeroPad;

// 手动创建ERC-20过滤器的简短实例
// 转账事件

// 大多数用户通常使用过合约的API来过滤计算，因为它更简单，但这是为那些
// 好奇的人提供一个例证
// 如下是等价于合约API的例子

// ERC-20:
//   Transfer(address indexed src, address indexed dst, uint val)
//
// -------------------^
// ----------------------------------------^
//
// 注意到只有 *src* and *dst* 被 *索引*, 因此只有这些符合过滤条件
//
// 并且，注意到在Solidity事件中使用第一个主题识别事件名称，对于转账函数如下：
//   id("Transfer(address,address,uint256)")
//
// 其他要注意的地方
//  - 一个主题必须是 32 字节; 添加的类型要尽可能短

// 列出所有通证 *来自于*  我的地址的转账
filter = {
    address: tokenAddress,
    topics: [
        id("Transfer(address,address,uint256)"),
        hexZeroPad(myAddress, 32)
    ]
};

// 列出所有通证 *转给*  我的地址的转账
filter = {
    address: tokenAddress,
    topics: [
        id("Transfer(address,address,uint256)"),
        null,
        hexZeroPad(myAddress, 32)
    ]
};

// 列出所有通证 *转给*  我的地址或者我的其他地址的转账
filter = {
    address: tokenAddress,
    topics: [
        id("Transfer(address,address,uint256)"),
        null,
        [
            hexZeroPad(myAddress, 32),
            hexZeroPad(myOtherAddress, 32),
        ]
    ]
};

_null:

在这里解释一下，为了简化， 合约的API如下：


_code: ERC-20 合约过滤例子 @lang<javascript>

//_hide: const tokenAddress = "0x6B175474E89094C44Da98b954EedeAC495271d0F"; /* DAI */
//_hide: const myAddress = "0x8ba1f109551bD432803012645Ac136ddd64DBA72";
//_hide: const otherAddress = "0xEA517D5a070e6705Cc5467858681Ed953d285Eb9";
//_hide: const provider = ethers.getDefaultProvider();
//_hide: const Contract = ethers.Contract;

abi = [
  "event Transfer(address indexed src, address indexed dst, uint val)"
];

contract = new Contract(tokenAddress, abi, provider);

// 列出所有通证 *来自于*  我的地址的转账
//_result:
contract.filters.Transfer(myAddress)
//_log:

// 列出所有通证 *转给*  我的地址的转账
//_result:
contract.filters.Transfer(null, myAddress)
//_log:

// 列出所有通证 *来自于*  我的或者我其他的地址的转账
//_result:
contract.filters.Transfer(myAddress, otherAddress)
//_log:

// 列出所有通证 *转给*  我的地址或者我的其他地址的转账
//_result:
contract.filters.Transfer(null, [ myAddress, otherAddress ])
//_log:


_subsection: Solidity Topics @<events-solidity>

This is a quick (and non-comprehensive) overview of how events are computed
in Solidity.

This is likely out of the scope for most developers, but may be interesting
to those who want to learn a bit more about the underlying technology.

Solidity provides two types of events, anonymous and non-anonymous. The
default is non-anonymous, and most developers will not need to worry about
anonymous events.

For non-anonymous events, up to 3 topics may be indexed (instead of 4), since
the first topic is reserved to specify the event signature. This allows
non-anonymous events to always be filtered by their event signature.

This topic hash is always in the first slot of the indexed data, and is
computed by normalizing the Event signature and taking the keccak256 hash
of it.

For anonymous events, up to 4 topics may be indexed, and there is no
signature topic hash, so the events cannot be filtered by the event
signature.

Each additional indexed property is processed depending on whether its
length is fixed or dynamic.

For fixed length types (e.g. ``uint``, ``bytes5``), all of which are
internally exactly 32 bytes (shorter types are padded with zeros;
numeric values are padded on the left, data values padded on the right),
these are included directly by their actual value, 32 bytes of data.

For dynamic types (e.g. ``string``, ``uint256[]``) , the value is hashed
using keccak256 and this hash is used.

Because dynamic types are hashed, there are important consequences in
parsing events that should be kept in mind. Mainly that the original
value is lost in the event. So, it is possible to tell is a topic is
equal to a given string, but if they do not match, there is no way
to determine what the value was.

If a developer requires that a string value is required to be both
able to be filtered and also able to be read, the value must be included
in the signature twice, once indexed and once non-indexed (e.g.
``someEvent(string indexed searchBy, string clearText)``).

For a more detailed description, please refer to the
[Solidity Event Documentation](link-solidity-events).

_heading: Other Things? TODO

Explain what happens to strings and bytes, how to filter and retain the value
